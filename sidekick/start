#!/bin/bash

check_image_downloaded() {
  local docker_url="$1"

  docker inspect \
    --format='{{.Id}}' \
    --type=image \
    "${docker_url}" > /dev/null
}

check_version() {
  local service_docker_name="$1"
  local docker_url="$2"
  current_docker_url=$(docker ps | grep "${service_docker_name}" | awk '{ print $2 }')
  if [ "${current_docker_url}" == "" ]; then
    return 0
  fi
  [ "${current_docker_url}" == "${docker_url}" ]
}

check_restart() {
  local restart_etcd_key="$1"
  local previous_restart_value="$2"
  local restart_value="$(get_restart "${restart_etcd_key}")"
  if [ "${restart_value}" == "" ]; then
    return 0
  fi
  [ "${restart_value}" == "${previous_restart_value}" ]
}

download_image() {
  local docker_url="$1"
  check_image_downloaded "${docker_url}"
  local image_downloaded=$?

  if [ "$image_downloaded" != "0" ]; then
    pull_image "$docker_url"
  fi
}

get_docker_url() {
  local etcd_docker_url_key="$1"
  etcdctl get "${etcd_docker_url_key}" 2>/dev/null
}

get_restart() {
  local etcd_restart_key="$1"
  etcdctl get "${etcd_restart_key}" 2>/dev/null
}

pull_image() {
  local docker_url="$1"

  docker pull "${docker_url}"
}

hup_docker() {
  local docker_name="$1"

  docker kill \
    --signal=HUP \
    "${docker_name}" > /dev/null
}

stop_docker() {
  local timeout="$1"
  local docker_name="$2"

  docker stop \
    --time="${timeout}" \
    "${docker_name}" > /dev/null
}

main(){
  local namespace="$1"
  local service_base_name="$2"
  local service_suffix="$3"
  local service_prefix="${namespace}-${service_base_name}"
  local etcd_dir="${namespace}/${service_base_name}"
  local docker_url_etcd_key="${etcd_dir}/docker_url"
  local restart_etcd_key="${etcd_dir}/restart"
  local register_docker_name
  local service_docker_name
  if [ "${service_suffix}" == "" ]; then
    register_docker_name="${service_prefix}-register"
    service_docker_name="${service_prefix}"
  else
    register_docker_name="${service_prefix}-register-${service_suffix}"
    service_docker_name="${service_prefix}-${service_suffix}"
  fi
  local restart_value="$(get_restart "${restart_etcd_key}")"
  local restart=0
  local timeout=10

  while true; do
    sleep $[ ( $RANDOM % 60 )  + 45 ]s # sleep random amount of time to stagger version check

    check_restart "${restart_etcd_key}" "${restart_value}"
    local exit_code=$?

    if [ "${exit_code}" != "0" ]; then
      echo "Restart value changed, restarting."
      restart=1
    fi

    local docker_url="$(get_docker_url "${docker_url_etcd_key}")"
    check_version "${service_docker_name}" "${docker_url}"
    local exit_code=$?

    if [ "${exit_code}" != "0" ]; then
      echo "Docker URL changed, restarting."
      restart=1
    fi

    if [ "${restart}" == "1" ]; then
      echo "Kronk sidekicking."
      download_image "${docker_url}"
      sleep $[ ( $RANDOM % 60 )  + 1 ]s # sleep random amount of time to stagger deployment
      hup_docker  "${register_docker_name}"
      sleep 3 # allow backend to be unregistered before stopping service
      stop_docker "${timeout}" "${register_docker_name}"
      stop_docker "${timeout}" "${service_docker_name}"
      exit 0 # restart to use latest kronk
    fi
  done
}
main $@
